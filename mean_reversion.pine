//@version=6
indicator("Mean Reversion Ladder Anchors (ETH Reset)", overlay=true, max_lines_count=500, max_labels_count=500)

//=============================
// ðŸ”§ Inputs
//=============================
thresholdPts   = input.float(50,  "Impulse Threshold (points)")
tolerancePts   = input.float(3,   "Anchor Reversion Tolerance")
anchorResetStr = input.string("1700", "Daily Anchor Reset Time (HHMM exchange time)")
showLabels     = input.bool(true, "Show Anchor Labels")
showLines      = input.bool(true, "Connect Anchors")

//=============================
// ðŸ•’ Parse reset time
//=============================
resetHour   = str.tonumber(str.substring(anchorResetStr, 0, 2))
resetMinute = str.tonumber(str.substring(anchorResetStr, 2, 4))

curHour   = hour(time)
curMinute = minute(time)

crossedReset =
     (curHour == resetHour and curMinute == resetMinute) and
     not (hour(time[1]) == resetHour and minute(time[1]) == resetMinute)

//=============================
// ðŸ§± State Variables
//=============================
var float current_anchor = na
var int   anchor_bar     = na

var bool  impulse_detected = false
var bool  reversion_done   = false
var int   impulse_bar_index = na
var int   impulse_dir = 0

// ladder storage
var anchor_levels = array.new_float()
var anchor_bars   = array.new_int()

//=============================
// ðŸ” Reset at ETH open
//=============================
if crossedReset
    current_anchor := open
    anchor_bar     := bar_index

    impulse_detected := false
    reversion_done   := false
    impulse_bar_index := na
    impulse_dir := 0

    array.clear(anchor_levels)
    array.clear(anchor_bars)

    array.push(anchor_levels, current_anchor)
    array.push(anchor_bars, bar_index)

//=============================
// ðŸŸ¡ Step 1: Detect impulse
//=============================
if not impulse_detected and not na(current_anchor)
    dist = close - current_anchor

    if math.abs(dist) >= thresholdPts
        impulse_detected := true
        impulse_bar_index := bar_index
        impulse_dir := dist > 0 ? +1 : -1

//=============================
// ðŸ”µ Step 2: Reversion back to anchor
//=============================
if impulse_detected and not reversion_done
    revert_dist = math.abs(close - current_anchor)

    if revert_dist <= tolerancePts
        reversion_done := true

        // ðŸ·ï¸ label how many bars it took to revert
        bars_to_revert = bar_index - impulse_bar_index

        if showLabels
            label.new(bar_index, current_anchor,
                text = "R:" + str.tostring(bars_to_revert),
                style = label.style_label_up,
                size = size.small,
                color = color.new(color.green, 0))

//=============================
// ðŸ”´ Step 3: New anchor (any direction)
//=============================
if impulse_detected and reversion_done
    dist = close - current_anchor

    if math.abs(dist) >= thresholdPts
        steps = math.round(dist / thresholdPts)
        new_anchor = current_anchor + steps * thresholdPts

        // store ladder point
        array.push(anchor_levels, new_anchor)
        array.push(anchor_bars, bar_index)

        // draw connecting line
        if showLines and array.size(anchor_levels) >= 2
            prev_level = array.get(anchor_levels, array.size(anchor_levels) - 2)
            prev_bar   = array.get(anchor_bars,   array.size(anchor_bars) - 2)

            line.new(prev_bar, prev_level, bar_index, new_anchor, width=2, color=color.orange)

        // label anchor
        if showLabels
            label.new(bar_index, new_anchor,
                text = "A\n" + str.tostring(new_anchor),
                style = label.style_label_down,
                size = size.small)

        // reset for next cycle
        current_anchor := new_anchor
        anchor_bar     := bar_index

        impulse_detected := false
        reversion_done   := false
        impulse_bar_index := na
        impulse_dir := 0

//=============================
// ðŸ“ˆ Stats Table (unchanged)
//=============================
var up_cycles   = array.new_int()
var down_cycles = array.new_int()

var table stats = table.new(position.top_right, 2, 3)

if bar_index % 20 == 0
    table.cell(stats, 0, 0, "Metric", bgcolor=color.gray)
    table.cell(stats, 1, 0, "Value", bgcolor=color.gray)

    table.cell(stats, 0, 1, "Anchors")
    table.cell(stats, 1, 1, str.tostring(array.size(anchor_levels)))

    table.cell(stats, 0, 2, "Last Anchor")
    table.cell(stats, 1, 2, str.tostring(current_anchor))

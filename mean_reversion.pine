//@version=6
indicator("Session Anchor Ladder (Mean Reversion Cycles)", overlay=true, max_lines_count=500, max_labels_count=500)

// =========================
// ðŸ”§ USER INPUTS
// =========================
sessionHour   = input.int(23, "Session Start Hour")
sessionMinute = input.int(0,  "Session Start Minute")

thresholdPts  = input.float(50.0, "Displacement Threshold (pts)")
tolerancePts  = input.float(5.0,  "Reversion Tolerance (pts)")

showLabels    = input.bool(true, "Show Anchor Labels")
showDurations = input.bool(true, "Show Cycle Durations")

// =========================
// ðŸ•’ SESSION START DETECTION
// =========================
isSessionStart = (hour == sessionHour and minute == sessionMinute)

// =========================
// ðŸ“¦ STATE VARIABLES
// =========================
var float current_anchor = na
var int   anchor_bar_index = na

var bool impulse_detected = false
var int  impulse_dir = 0            // +1 up, -1 down
var int  impulse_bar_index = na

var bool reversion_done = false

// ladder arrays
var float[] anchor_levels = array.new_float()
var int[]   anchor_bars   = array.new_int()

// stats arrays
var int[] up_cycles   = array.new_int()
var int[] down_cycles = array.new_int()

// line/label storage
var line[] ladder_lines = array.new_line()
var label[] ladder_labels = array.new_label()

// =========================
// ðŸ”„ RESET AT SESSION START
// =========================
if isSessionStart
    // reset everything
    current_anchor := open
    anchor_bar_index := bar_index

    impulse_detected := false
    impulse_dir := 0
    reversion_done := false

    // clear arrays
    array.clear(anchor_levels)
    array.clear(anchor_bars)
    array.clear(up_cycles)
    array.clear(down_cycles)

    // store first anchor
    array.push(anchor_levels, current_anchor)
    array.push(anchor_bars, anchor_bar_index)

    // optional label
    if showLabels
        label.new(bar_index, current_anchor, "A0\n" + str.tostring(current_anchor), style=label.style_label_down, color=color.rgb(59, 128, 255))

// =========================
// ðŸš¦ STATE MACHINE LOGIC
// =========================

// --- Step 1: detect displacement from current anchor
distance = close - current_anchor

if not impulse_detected
    if distance >= thresholdPts
        impulse_detected := true
        impulse_dir := +1
        impulse_bar_index := bar_index
    else if distance <= -thresholdPts
        impulse_detected := true
        impulse_dir := -1
        impulse_bar_index := bar_index

// --- Step 2: wait for reversion to anchor
if impulse_detected and not reversion_done
    reverted = math.abs(close - current_anchor) <= tolerancePts or
               (impulse_dir == +1 and close < current_anchor) or
               (impulse_dir == -1 and close > current_anchor)

    if reverted
        reversion_done := true

// --- Step 3: wait for opposite displacement to form NEW anchor
if impulse_detected and reversion_done
    oppDistance = close - current_anchor

    new_anchor_condition =
         (impulse_dir == +1 and oppDistance <= -thresholdPts) or
         (impulse_dir == -1 and oppDistance >= thresholdPts)

    if new_anchor_condition
        // determine new anchor level
        float new_anchor = current_anchor + (impulse_dir == +1 ? -thresholdPts : thresholdPts)

        // store cycle duration
        int duration = bar_index - impulse_bar_index

        if impulse_dir == +1
            array.push(up_cycles, duration)
        else
            array.push(down_cycles, duration)

        // store ladder anchor
        array.push(anchor_levels, new_anchor)
        array.push(anchor_bars, bar_index)

        // draw line between last two anchors
        int size = array.size(anchor_levels)
        if size >= 2
            float prev_price = array.get(anchor_levels, size - 2)
            int   prev_bar   = array.get(anchor_bars, size - 2)

            line l = line.new(prev_bar, prev_price, bar_index, new_anchor, width=2,
                 color = impulse_dir == +1 ? color.red : color.green)
            array.push(ladder_lines, l)

            if showDurations
                label.new(bar_index, new_anchor,
                    str.tostring(duration) + " bars",
                    style=label.style_label_left,
                    color=color.new(color.gray, 20))

        // label new anchor
        if showLabels
            label.new(bar_index, new_anchor,
                "A" + str.tostring(size-1) + "\n" + str.tostring(new_anchor),
                style=label.style_label_down,
                color=color.rgb(82, 196, 148))

        // update state for next cycle
        current_anchor := new_anchor
        anchor_bar_index := bar_index

        impulse_detected := false
        reversion_done := false
        impulse_dir := 0

// =========================
// ðŸ“Š STATS TABLE
// =========================
var table statsTable = table.new(position.top_right, 2, 3)

f_avg(arr) =>
    int s = array.size(arr)
    if s == 0
        na
    else
        float sum = 0.0
        for i = 0 to s - 1
            sum += array.get(arr, i)
        sum / s

if barstate.islast
    float avgUp   = f_avg(up_cycles)
    float avgDown = f_avg(down_cycles)

    table.cell(statsTable, 0, 0, "Up Cycles Avg Bars")
    table.cell(statsTable, 1, 0, str.tostring(avgUp, "#.0"))

    table.cell(statsTable, 0, 1, "Down Cycles Avg Bars")
    table.cell(statsTable, 1, 1, str.tostring(avgDown, "#.0"))

    table.cell(statsTable, 0, 2, "Total Anchors")
    table.cell(statsTable, 1, 2, str.tostring(array.size(anchor_levels)))

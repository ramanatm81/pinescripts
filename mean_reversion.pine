//@version=6
indicator("Mean Reversion Ladder Anchors (ETH Reset)", overlay=true, max_lines_count=500, max_labels_count=500)

//=============================
// ðŸ”§ Inputs
//=============================
thresholdPts   = input.float(50,  "Impulse Threshold (points)")
tolerancePts   = input.float(3,   "Anchor Reversion Tolerance")
anchorResetStr = input.string("1700", "Daily Anchor Reset Time (HHMM exchange time)")
showLabels     = input.bool(true, "Show Anchor Labels")
showLines      = input.bool(true, "Connect Anchors")

//=============================
// ðŸ•’ Parse reset time
//=============================
resetHour   = str.tonumber(str.substring(anchorResetStr, 0, 2))
resetMinute = str.tonumber(str.substring(anchorResetStr, 2, 4))

// current bar time components (exchange time)
curHour   = hour(time)
curMinute = minute(time)

// detect crossing of reset time
crossedReset =
     (curHour == resetHour and curMinute == resetMinute) and
     not (hour(time[1]) == resetHour and minute(time[1]) == resetMinute)

//=============================
// ðŸ§± State Variables
//=============================
var float current_anchor = na
var int   anchor_bar     = na

var bool  impulse_detected = false
var bool  reversion_done   = false
var int   impulse_bar_index = na
var int   impulse_dir = 0  // +1 up, -1 down

// storage for ladder drawing
var anchor_levels = array.new_float()
var anchor_bars   = array.new_int()

// stats
var up_cycles   = array.new_int()
var down_cycles = array.new_int()

//=============================
// ðŸ” Reset at ETH open (17:00)
//=============================
if crossedReset
    current_anchor := open
    anchor_bar     := bar_index

    impulse_detected := false
    reversion_done   := false
    impulse_bar_index := na
    impulse_dir := 0

    array.clear(anchor_levels)
    array.clear(anchor_bars)

    array.push(anchor_levels, current_anchor)
    array.push(anchor_bars, bar_index)

//=============================
// ðŸŸ¡ Step 1: Detect impulse from anchor
//=============================
if not impulse_detected and not na(current_anchor)
    dist = close - current_anchor

    if math.abs(dist) >= thresholdPts
        impulse_detected := true
        impulse_bar_index := bar_index
        impulse_dir := dist > 0 ? +1 : -1

//=============================
// ðŸ”µ Step 2: Wait for reversion to anchor
//=============================
if impulse_detected and not reversion_done
    revert_dist = math.abs(close - current_anchor)

    if revert_dist <= tolerancePts
        reversion_done := true

//=============================
// ðŸ”´ Step 3: Next displacement â†’ new anchor (ANY direction)
//=============================
if impulse_detected and reversion_done
    dist = close - current_anchor

    if math.abs(dist) >= thresholdPts
        // snap to ladder step
        steps = math.round(dist / thresholdPts)
        new_anchor = current_anchor + steps * thresholdPts

        // cycle duration
        duration = bar_index - impulse_bar_index

        if dist > 0
            array.push(up_cycles, duration)
        else
            array.push(down_cycles, duration)

        // store ladder point
        array.push(anchor_levels, new_anchor)
        array.push(anchor_bars, bar_index)

        // draw connecting line
        if showLines and array.size(anchor_levels) >= 2
            prev_level = array.get(anchor_levels, array.size(anchor_levels) - 2)
            prev_bar   = array.get(anchor_bars,   array.size(anchor_bars) - 2)

            line.new(prev_bar, prev_level, bar_index, new_anchor, width=2, color=color.orange)

        // label anchor
        if showLabels
            label.new(bar_index, new_anchor,
                text = "A\n" + str.tostring(new_anchor),
                style = label.style_label_down,
                size = size.small)

        // reset for next cycle
        current_anchor := new_anchor
        anchor_bar     := bar_index

        impulse_detected := false
        reversion_done   := false
        impulse_bar_index := na
        impulse_dir := 0

//=============================
// ðŸ“Š Plot current anchor
//=============================
plot(current_anchor, title="Current Anchor", color=color.yellow, linewidth=2)

//=============================
// ðŸ“ˆ Stats table
//=============================
var table stats = table.new(position.top_right, 2, 4)

avg_up = array.size(up_cycles) > 0 ? array.avg(up_cycles) : na
avg_dn = array.size(down_cycles) > 0 ? array.avg(down_cycles) : na

if bar_index % 10 == 0
    table.cell(stats, 0, 0, "Metric", bgcolor=color.gray)
    table.cell(stats, 1, 0, "Value", bgcolor=color.gray)

    table.cell(stats, 0, 1, "Avg Up Cycle")
    table.cell(stats, 1, 1, str.tostring(avg_up))

    table.cell(stats, 0, 2, "Avg Down Cycle")
    table.cell(stats, 1, 2, str.tostring(avg_dn))

    table.cell(stats, 0, 3, "Total Anchors")
    table.cell(stats, 1, 3, str.tostring(array.size(anchor_levels)))

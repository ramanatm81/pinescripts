//@version=6
indicator("Mean Reversion Ladder Anchors (ETH Reset)", overlay=true, max_lines_count=500, max_labels_count=500)

//=============================
// Inputs
//=============================
thresholdPts   = input.float(50,  "Impulse Threshold (points)")
tolerancePts   = input.float(3,   "Anchor Reversion Tolerance")
anchorResetStr = input.string("1700", "Daily Anchor Reset Time (HHMM exchange time)")
showLabels     = input.bool(true, "Show Reset Labels")
showLines      = input.bool(true, "Connect Anchors")

//=============================
// Parse reset time
//=============================
resetHour   = str.tonumber(str.substring(anchorResetStr, 0, 2))
resetMinute = str.tonumber(str.substring(anchorResetStr, 2, 4))

curHour   = hour(time)
curMinute = minute(time)

crossedReset =
     (curHour == resetHour and curMinute == resetMinute) and
     not (hour(time[1]) == resetHour and minute(time[1]) == resetMinute)

//=============================
// State Variables
//=============================
var float current_anchor = na
var int   anchor_bar     = na

var bool  impulse_detected  = false
var int   impulse_bar_index = na
var float impulse_dist      = na

// ladder storage
var anchor_levels = array.new_float()
var anchor_bars   = array.new_int()

// reversion timing stats
var int cur_loiter      = 0   // bars this cycle where close stayed on impulse side
var int revert_count    = 0   // completed reversion cycles
var int revert_bars_sum = 0   // sum of bars from impulse → reversion
var int loiter_bars_sum = 0   // sum of loiter bars across cycles

//=============================
// Reset at ETH open
//=============================
if crossedReset
    current_anchor := open
    anchor_bar     := bar_index

    impulse_detected  := false
    impulse_bar_index := na
    impulse_dist      := na
    cur_loiter        := 0

    array.clear(anchor_levels)
    array.clear(anchor_bars)

    array.push(anchor_levels, current_anchor)
    array.push(anchor_bars, bar_index)

    if showLabels
        label.new(bar_index, current_anchor,
            text = "RESET" +
                "\nL:" + str.tostring(current_anchor, "#.##"),
            
            style = label.style_label_down,
            size = size.normal,
            color = color.new(color.blue, 0),
            textcolor = color.white)

//=============================
// Step 1: Detect impulse
//=============================
if not impulse_detected and not na(current_anchor)
    dist = close - current_anchor

    if math.abs(dist) >= thresholdPts
        impulse_detected  := true
        impulse_bar_index := bar_index
        impulse_dist      := dist

        label.new(bar_index, close,
            text = "#" + str.tostring(bar_index) + "\n" + str.tostring(close, "#.##"),
            style = dist > 0 ? label.style_label_down : label.style_label_up,
            size = size.small,
            color = dist > 0 ? color.new(color.green, 0) : color.new(color.red, 0),
            textcolor = color.white)

//=============================
// Step 2: Reversion back to anchor
//=============================
if impulse_detected
    // count bars where close is still on the impulse side (loitering above/below anchor)
    if (impulse_dist > 0 and close > current_anchor) or (impulse_dist < 0 and close < current_anchor)
        cur_loiter += 1

    // reversion: candle crosses back past the anchor from the impulse side
    reverted = impulse_dist > 0 ? low <= current_anchor : high >= current_anchor

    if reverted
        new_anchor = close  // use close as new anchor; candle touched the level but may have overshot

        // store ladder point
        array.push(anchor_levels, new_anchor)
        array.push(anchor_bars, bar_index)

        // draw connecting line
        if showLines and array.size(anchor_levels) >= 2
            prev_level = array.get(anchor_levels, array.size(anchor_levels) - 2)
            prev_bar   = array.get(anchor_bars,   array.size(anchor_bars) - 2)

            line.new(prev_bar, prev_level, bar_index, new_anchor, width=2, color=color.orange)

        label.new(bar_index, close,
            text = "ANCHOR\n#" + str.tostring(bar_index) + "\n" + str.tostring(close, "#.##"),
            style = impulse_dist > 0 ? label.style_label_up : label.style_label_down,
            size = size.small,
            color = color.new(color.orange, 0),
            textcolor = color.white)

        // accumulate timing stats
        revert_count    += 1
        revert_bars_sum += bar_index - impulse_bar_index
        loiter_bars_sum += cur_loiter
        cur_loiter       := 0

        // reset for next cycle from the reversion point
        current_anchor    := new_anchor
        anchor_bar        := bar_index
        impulse_detected  := false
        impulse_bar_index := na

//=============================
// Stats Table
//=============================
var up_cycles   = array.new_int()
var down_cycles = array.new_int()

var table stats = table.new(position.top_right, 2, 5)

if bar_index % 20 == 0
    avg_revert = revert_count > 0 ? revert_bars_sum / revert_count : 0
    avg_loiter = revert_count > 0 ? loiter_bars_sum / revert_count : 0

    table.cell(stats, 0, 0, "Metric",       bgcolor=color.gray, text_color=color.white)
    table.cell(stats, 1, 0, "Value",        bgcolor=color.gray, text_color=color.white)

    table.cell(stats, 0, 1, "Anchors")
    table.cell(stats, 1, 1, str.tostring(array.size(anchor_levels)))

    table.cell(stats, 0, 2, "Last Anchor")
    table.cell(stats, 1, 2, str.tostring(current_anchor, "#.##"))

    table.cell(stats, 0, 3, "Avg Bars→Revert")
    table.cell(stats, 1, 3, str.tostring(math.round(avg_revert)))

    table.cell(stats, 0, 4, "Avg Loiter Bars")
    table.cell(stats, 1, 4, str.tostring(math.round(avg_loiter)))
